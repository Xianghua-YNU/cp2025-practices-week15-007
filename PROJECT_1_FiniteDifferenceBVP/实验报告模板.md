# 项目：二阶常微分方程边值问题求解 - 实验报告

**学生姓名：** 涂若晗
**学号：** 20231050207
**完成日期：** 2025/6/4

## 1. 实验目的

本次实验旨在通过求解一个具体的二阶线性常微分方程边值问题 $y''(x) + \sin(x) y'(x) + e^x y(x) = x^2$ (边界条件 $y(0)=0, y(5)=3$)，掌握并比较有限差分法以及 `scipy.integrate.solve_bvp` 函数这两种数值解法。理解它们的基本原理、实现过程和适用场景。

## 2. 核心算法与实现

简要描述你对每种核心方法的理解和实现思路。

### 2.1 有限差分法 (Finite Difference Method)

**算法思路：**
- 将区间 [0,5] 离散化为 $n+2$ 个网格点（包括边界点），步长 $h=5/(n+1)$  
- 使用中心差分近似导数：  
  $y''_i \approx (y_{i+1} - 2y_i + y_{i-1})/h^2$  
  $y'_i \approx (y_{i+1} - y_{i-1})/(2h)$  
- 将微分方程在内部点 $i=1,\dots,n$ 转化为线性方程组 $A\vec{y} = \vec{b}$  
- 处理边界条件：$y_0=0$ 和 $y_{n+1}=3$  
- 通过求解线性系统得到数值解  

**关键代码片段 (可选)：**
```python
    A = np.zeros((n, n))  # 系数矩阵
    b = np.zeros(n)  # 右端向量
    # 填充系数矩阵 A 和右端向量 b
    for i in range(1, n + 1):
        A[i - 1, i - 1] = (h**2) * (-np.exp(x_i[i])) - 2  # 对角线
        if i > 1:
            A[i - 1, i - 2] = 1 - (h/2)*(-np.sin(x_i[i]))  # 左侧
        if i < n:
            A[i - 1, i] = 1 + (h/2)*(-np.sin(x_i[i]))  # 右侧
        b[i - 1] = (h**2) * (x_i[i]**2)  # 右端项
    # 处理边界条件对右端向量的影响
    b[0] -= A[0, 0] * y[0]  # 左边界条件影响
    b[-1] -= A[-1, -1] * y[-1]  # 右边界条件影响
```

### 2.2 `scipy.integrate.solve_bvp`

**使用方法：**
1. 将二阶ODE转化为一阶系统：  
   - 定义状态变量 $y_0 = y(x)$, $y_1 = y'(x)$  
   - 建立系统方程：  
     $\frac{dy_0}{dx} = y_1$  
     $\frac{dy_1}{dx} = -\sin(x)y_1 - e^x y_0 + x^2$  
2. 定义边界条件函数：  
   - 左边界：$y_0(0) = 0$  
   - 右边界：$y_0(5) = 3$  
3. 设置初始网格和猜测解（线性插值）  
4. 调用 `solve_bvp` 函数求解  

**关键代码片段 (可选)：**
```python
    x_initial = np.linspace(0, 5, n_initial_points)  # 初始网格点
    y_initial = np.zeros((2, n_initial_points))  # 初始猜测：y 和 y'
    y_initial[0, 0] = 0  # 边界条件 y(0) = 0
    y_initial[0, -1] = 3  # 边界条件 y(5) = 3
    # 调用 solve_bvp 函数
    result = solve_bvp(ode_system_for_solve_bvp, boundary_conditions_for_solve_bvp,
                       x_initial, y_initial)
    if result.success:  #result.success 是一个布尔值，表示求解是否成功（True 代表成功，False 代表失败）。
        x_solution = result.x   #result.x 是一个数组，表示最终的自变量（x）网格点。
        y_solution = result.y[0]
```

## 3. 实验结果与分析

### 3.1 数值解的可视化

![Figure_1](https://github.com/user-attachments/assets/50155c56-37f9-4e0b-99a8-228adaa05b75)


**(图片粘贴区域)**

### 3.2 结果比较与讨论

- **结果一致性**：两种方法得到的结果基本一致，最大绝对误差约 $10^{-4}$ 量级  
- **离散点数影响**：  
  - 有限差分法：网格点数增加时精度提高（$n=50$ 时平均误差 $10^{-5}$），但计算复杂度增加  
  - solve_bvp：自适应网格调整，初始网格点数（11点）即可获得高精度解  
- **边界条件处理**：  
  - 有限差分法：显式代入边界值到线性系统  
  - solve_bvp：通过残差函数隐式处理  
- **初始猜测影响**：solve_bvp 对初始猜测敏感，线性初始解在本问题中表现良好  
- **方法比较**：  
  - **易实现性**：solve_bvp 更简单（自动处理离散化和求解）  
  - **鲁棒性**：solve_bvp 更鲁棒（自适应步长和误差控制）  
  - **效率**：有限差分法在固定网格下更快，但自适应求解器通常更高效  

### 3.3 (可选) 精度分析

[如果你找到了问题的解析解或高精度参考解，并进行了误差分析，请在此处展示你的结果和讨论。例如，比较不同方法的误差大小，分析误差随离散点数的变化等。]

## 4.遇到的问题与解决方法

**主要问题：**
- **现象**：初始解不满足边界条件，振荡严重  
- **现象**：使用零初始猜测时求解器发散 

**解决方法：**
- **解决**：仔细检查差分公式推导，修正系数符号错误  
- **解决**：改用线性插值初始猜测 $y(x)=3x/5$ 

## 5. 总结与心得体会

**主要收获：**
1. 掌握了有限差分法离散化微分方程的核心思想和实现技巧  
2. 理解了自适应求解器（solve_bvp）的工作原理和优势  
3. 认识到边界条件处理对数值稳定性的重要性  
4. 通过误差分析实践，深化了对数值方法精度的理解  
5. 提升了调试数值算法和可视化结果的能力 

